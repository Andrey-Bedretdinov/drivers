ЛР1

1) Написать символьный драйвер с read, write, ioctl
2) Написать тест приложение читающее int, пишущее int
3) В драйвере померить время между чтением и записью
4) По ioctl в драйвере выдавать гистограмму при помощи printk

Гистограмма 20 бинов (пусть 1 бин - 50 микросекунд). Нормализовывать гистограмму не надо

---

### Написал символьный драйвер
Собрал минимальный драйвер с поддержкой:
- open / close
- read / write
- ioctl (2 команды: получить длину гистограммы и сам буфер)

В `write()` кладу число во внутренний буфер и фиксирую момент времени (`jiffies`).  
В `read()` возвращаю число и считаю, сколько микросекунд прошло с момента записи.

Разница во времени попадала в один из 20 бинов гистограммы:

- ширина бина — **50 мкс**
- `delta_us = jiffies_to_usecs(delta)`
- `bin = delta_us / 50`

Если бин выходит за границы — отправляю всё в последний.

Гистограмма накапливается в массиве `size_t histogram[20]`.

### Сделал приложение для проверки драйвера
Приложение открывает драйвер дважды: на чтение и на запись.  
Дальше в цикле 1000 раз:

- отправляю число в драйвер (`write`)
- делаю *микрозадержку* через `usleep(1)`
- читаю число обратно (`read`)

После цикла забираю гистограмму через ioctl:

```
IOCTL_GET_HIST_LEN
IOCTL_GET_HIST_BUF
```

### Исправлял задержку, чтобы распределение было нормальным
Подбирал `usleep()`, чтобы значения не сваливались всегда в бин 0 или бин 19.  
Остановился на `usleep(1)`, потому что это даёт равномерное распределение по многим бинам, но с естественным перекосом в правый край


---

## Использованный драйвер (основная логика)

```c
unsigned long delta = jiffies - last_write_time;
unsigned long delta_us = jiffies_to_usecs(delta);

int bin = delta_us / BIN_WIDTH_US;
if (bin >= MAX_BINS)
    bin = MAX_BINS - 1;

histogram[bin]++;
```

## Использованное приложение (основная логика)

```c
for (size_t i = 0; i < 1000; i++) {
    write(writer_fd, &i, sizeof(int));
    usleep(1);
    read(reader_fd, &i, sizeof(int));
}
```

## Итоговый вывод

```
Гистограмма, длина = 20
00:     7
01:     18
02:     18
03:     19
04:     17
05:     17
06:     18
07:     18
08:     18
09:     17
10:     18
11:     17
12:     18
13:     18
14:     17
15:     18
16:     18
17:     17
18:     17
19:     675
```